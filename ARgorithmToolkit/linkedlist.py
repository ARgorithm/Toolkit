# pylint: disable=protected-access
"""The linkedlist module provides support for rendering linked lists.

linkedlist module provides the LinkedListNode for your nodes useful for
explanation and the Linkedlist class which is useful for application.

- The LinkedListNode class is used to represent a node.
- The LinkedList class is a complete implementation of singly linked list

These three classes can be directly imported from the toolkit:

    >>> llnode = ARgorithmToolkit.LinkedListNode(algo,7)
    >>> ll = ARgorithmToolkit.LinkedList("llnode",algo,llnode)

"""

from ARgorithmToolkit.utils import ARgorithmHashable, ARgorithmStructure, State, StateSet, ARgorithmError
from ARgorithmToolkit.encoders import serialize

class LinkedListNodeState:
    """This class is used to generate states for various actions performed on
    the ``ARgorithmToolkit.linkedlist.LinkedListNode`` object.

    Attributes:

        name (str) : Name of the variable for whom we are generating states
        _id (str) : id of the variable for whom we are generating states
    """

    def __init__(self,name:str,_id:str):
        self.name = name
        self._id = _id

    def llnode_declare(self,value,_next,comments=""):
        """Generates the `llnode_declare` state when a new node is created.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to "".

        Returns:
            State: Returns the `llnode_declare` state
        """
        state_type = "llnode_declare"
        state_def = {
            "id" : self._id,
            "variable_name" : self.name,
            "value" : value,
            "next" : _next._id if _next else "none"
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_iter(self,value,_next,last_value=None,comments=""):
        """Generates the `llnode_iter` state when a node is accessed or its
        value is changed.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to "".

        Returns:
            State: Returns the `llnode_iter` state
        """
        state_type = "llnode_iter"
        state_def = {
            "id" : self._id,
            "variable_name" : self.name,
            "value" : value,
            "next" : _next._id if _next else "none"
        }
        if not(last_value is None):
            state_def["last_value"] = last_value
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_next(self,value,_next,last_next,comments=""):
        """Generates the `llnode_next` state when the next pointer changes.

        Args:
            value : The value stored in the linkedlist node
            next (LinkedListNode): The next pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to "".

        Returns:
            State: Returns the `llnode_next` state
        """
        state_type = "llnode_next"
        state_def = {
            "id" : self._id,
            "variable_name" : self.name,
            "value" : value,
            "next" : _next._id if _next else "none",
            "last_next" : last_next._id if last_next else "none"
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def llnode_delete(self,comments=""):
        """Generates the `llnode_delete` state when a node is deleted.

        Args:
            comments (str, optional): Comments for descriptive purpose. Defaults to "".

        Returns:
            State: Returns the `llnode_delete` state
        """
        state_type = "llnode_delete"
        state_def = {
            "id" : self._id,
            "variable_name" : self.name,
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

@serialize
class LinkedListNode(ARgorithmStructure, ARgorithmHashable):
    """The LinkedListNode class is an implementation of a Linked list Node for
    which we store states. Unlike other data structure classes, in which we
    have to give a name to the instance, we dont have to provide name in the
    LinkedListNode Class.

    Attributes:
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of LinkedListNode Class
        value: The value stored in the node
        next (LinkedListNode): The reference to next node

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        >>> llnode = ARgorithmToolkit.LinkedListNode(algo,7)
        >>> llnode.value = 10
        >>> temp = = ARgorithmToolkit.LinkedListNode(algo,7)
        >>> temp.next = llnode
        >>> llnode = temp
    """
    def __init__(self,algo:StateSet,value,comments=""):
        self.name = str(id(self))
        self._id = str(id(self))
        try:
            assert isinstance(algo,StateSet)
            self.algo = algo
        except AssertionError as e:
            raise ARgorithmError("algo should be of type StateSet") from e

        self.state_generator = LinkedListNodeState(self.name, self._id)

        self._value = value
        self._next = None

        state = self.state_generator.llnode_declare(
            self._value,self._next,comments
        )
        self.algo.add_state(state)

    def highlight(self):
        """The highlight function trigger the `llnode_iter` state
        """
        state = self.state_generator.llnode_iter(self._value,self._next)
        self.algo.add_state(state)

    @property
    def value(self):
        """Getter function for the value of node

        Example:
            >>> ll = LinkedListNode(algo,3)
            >>> ll.value
            3
        """
        self.highlight()
        return self._value

    @value.setter
    def value(self,v):
        """Setter function for the value of node

        Example:
            >>> ll = LinkedListNode(algo,3)
            >>> ll.value = 4
            >>> ll.value
            4
        """
        last = self._value
        self._value = v
        state = self.state_generator.llnode_iter(self._value,self._next,last_value=last)
        self.algo.add_state(state)

    @property
    def next(self):
        """Getter function for the next node

        Example:
            >>> ll.next            
        """
        if self._next:
            self._next.highlight()
        return self._next

    @next.setter
    def next(self,n):
        """Setter function for the next node

        Example:
            >>> ll.next = LinkedListNode(algo,5)

        Raises:
            TypeError: if the next node is not None or of type `LinkedListNode`
        """
        try:
            assert n is None or isinstance(n,LinkedListNode)
        except AssertionError as ae:
            raise TypeError("next attribute can only set as None or instance of LinkedListNode")
        last = self._next
        self._next = n
        if self._next is not None or last is not None:
            state = self.state_generator.llnode_next(self._value,self._next,last_next=last)
            self.algo.add_state(state)
    
    def __del__(self):
        """The __del__ function is overriden is there to listen to node
        deletion."""
        state = self.state_generator.llnode_delete(
            "Node was deleted"
        )
        self.algo.add_state(state)

    def __str__(self):
        return f"LinkedListNode({self._value}) at {self._id}"

    def __repr__(self):
        return f"LinkedListNode({self._value}) at {self._id}"

class LinkedListState:
    """This class is used to generate states for various actions performed on
    the ``ARgorithmToolkit.linkedlist.LinkedList`` object.

    Attributes:

        name (str) : Name of the variable for whom we are generating states
        _id (str) : id of the variable for whom we are generating states
    """
    def __init__(self,name:str,_id:str):
        self.name = name
        self._id = _id

    def ll_declare(self,head,comments=""):
        """Generates the `ll_declare` state when a new linkedlist is created.

        Args:
            head (LinkedListNode): The head pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to "".

        Returns:
            State: Returns the `ll_declare` state
        """
        state_type = "ll_declare"
        state_def = {
            "id" : self._id,
            "variable_name" : self.name,
            "head" : head._id if head else "none"
        }
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

    def ll_head(self,head,last_head=None,comments=""):
        """Generates the `ll_head` state when linkedlist head is changed.

        Args:
            head (LinkedListNode): The head pointer
            comments (str, optional): Comments for descriptive purpose. Defaults to "".

        Returns:
            State: Returns the `ll_head` state
        """
        state_type = "ll_head"
        state_def = {
            "id" : self._id,
            "variable_name" : self.name,
            "head" : head._id if head else "none"
        }
        if not (last_head is None):
            state_def["last_head"] = last_head
        return State(
            state_type=state_type,
            state_def=state_def,
            comments=comments
        )

class LinkedListIterator:
    """This class is a generator that is returned each time an LinkedList has
    to be iterated.

    Yields:
        Value of LinkedList Node

    Raises:
        AssertionError: If not declared with an instance of ARgorithmToolkit.linkedlist.LinkedList
    """
    def __init__(self,linkedlist):
        assert isinstance(linkedlist,LinkedList)
        self._curr = linkedlist.head

    def __next__(self):
        if self._curr:
            data = self._curr.value
            self._curr = self._curr.next
            return data
        raise StopIteration

@serialize
class LinkedList:
    """The LinkedList class is proper implementation of singly linked list.

    Attributes:
        name (str): The name given to the linkedlist
        algo (ARgorithmToolkit.utils.StateSet): The stateset that will store the states generated by the instance of LinkedList Class
        head (LinkedListNode): The referece to head of linkedlist

    Raises:
        ARgorithmError: Raised if algo is not of type StateSet

    Example:

        >>> fl = ARgorithmToolkit.LinkedList("fl",algo)
    """

    def __init__(self,name:str,algo:StateSet,comments=""):
        assert isinstance(name,str) , ARgorithmError("Name should be of type string")
        self.name = name
        self._id = str(id(self))
        try:
            assert isinstance(algo,StateSet)
            self.algo = algo
        except AssertionError as e:
            raise ARgorithmError("algo should be of type StateSet") from e
        self.state_generator = LinkedListState(self.name, self._id)

        self._head = None
        state = self.state_generator.ll_declare(self._head,comments)
        self.algo.add_state(state)

    @property
    def head(self):
        return self._head

    @head.setter
    def head(self,h):
        if h:
            assert isinstance(h,LinkedListNode) , ARgorithmError("next should be of type None or LinkedListNode")
        last_head = self._head._id if self._head else None
        self._head = h
        state = self.state_generator.ll_head(self.head,last_head=last_head, comments="head pointer shifts")
        self.algo.add_state(state)

    def __len__(self):
        """overloads the len() operator to return size of list.

        Returns:
            int: size of list

        Example:

            >>> fl = ARgorithmToolkit.LinkedList("fl",algo)
            >>> fl.push_front(1)
            >>> len(fl)
            1
        """
        size = len(self.tolist())
        return size

    def insert(self,value,index=0):
        """Insert node with given value at particular index. If index is not
        given,insert at front.

        Args:
            value : The value to be inserted
            index (int, optional): The index where value has to inserted . Defaults to 0.

        Example:

            >>> fl = ARgorithmToolkit.LinkedList("fl",algo)
            >>> fl.insert(2)
            >>> fl.insert(4)
            >>> fl.insert(3,1)
            >>> fl
            LinkedList([4, 3, 2])
        """
        if self._head is None or index == 0:
            self.push_front(value)
        else:
            count = 1
            temp = self.head
            while index > count:
                count += 1
                temp = temp.next
            curr = LinkedListNode(self.algo,value)
            curr.next = temp.next
            temp.next = curr

    def push_front(self,value):
        """Pushes value to front.

        Args:
            value : Value to be appended to front

        Example:
            >>> fl = ARgorithmToolkit.LinkedList("fl",algo)
            >>> fl
            LinkedList([])
            >>> fl.push_front(1)
            >>> fl
            LinkedList([1])
        """
        curr = LinkedListNode(self.algo,value)
        if self._head:
            curr.next = self.head
            self.head = curr
        else:
            curr.next = None
            self.head = curr

    def pop_front(self):
        """Pops first element of linkedlist.

        Raises:
            ARgorithmError: Raised if list is empty

        Returns:
            element: The first element of list

        Example:

            >>> fl
            LinkedList([2, 1])
            >>> fl.pop_front()
            2
        """
        if self._head is None:
            raise ARgorithmError("Empty list")
        data = self.head.value
        temp = self.head
        self.head = self.head.next
        del temp
        return data

    def front(self):
        """Returns the first element of list.

        Raises:
            ARgorithmError: Raised when list is empty

        Returns:
            element: The first element of list

        Example:

            >>> fl
            LinkedList([2, 1])
            >>> fl.front()
            2
        """
        if self._head is None:
            raise ARgorithmError("Empty list")
        return self._head.value

    def __iter__(self):
        """Returns the generator object to iterate through elements of
        LinkedList.

        Returns:
            LinkedListIterator: Generator class for LinkedList

        Example:

            >>> [x for x in fl]
            [2, 2, 1]
        """
        return LinkedListIterator(self)

    def remove(self,value):
        """Remove elements with given value from list.

        Args:
            value : The value which has to be removed

        Raises:
            ARgorithmError: Raised if list is empty

        Example:

            >>> fl
            LinkedList([2, 2, 1])
            >>> fl.remove(2)
            >>> fl
            LinkedList([1])
        """
        if self._head is None:
            raise ARgorithmError("Empty list")
        while value == self.head.value:
            temp = self.head
            self.head = self.head.next
            del temp
            if self.head is None:
                return
        curr = self.head
        while curr:
            if curr._next:
                if curr._next.value == value:
                    temp = curr.next
                    curr.next = curr.next.next
                    del temp
                    continue
            curr = curr.next

    def tolist(self):
        """Converts the LinkedList to python list.

        Returns:
            list: list of LinkedList items

        Example:

            >>> fl
            LinkedList([3, 1])
            >>> fl.tolist()
            [3, 1]
        """
        curr = self._head
        data = []
        while curr:
            data.append(curr._value)
            curr = curr._next
        return data

    def __repr__(self):
        return f"LinkedList({self.tolist()})"

    def __str__(self):
        return f"LinkedList({self.tolist()})"
